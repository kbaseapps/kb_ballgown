# -*- coding: utf-8 -*-
############################################################
#
# Autogenerated by the KBase type compiler -
# any changes made here will be overwritten
#
############################################################

from __future__ import print_function
# the following is a hack to get the baseclient to import whether we're in a
# package or not. This makes pep8 unhappy hence the annotations.
try:
    # baseclient and this client are in a package
    from .baseclient import BaseClient as _BaseClient  # @UnusedImport
except ImportError:
    # no they aren't
    from baseclient import BaseClient as _BaseClient  # @Reimport


class KBaseFeatureValues(object):

    def __init__(
            self, url=None, timeout=30 * 60, user_id=None,
            password=None, token=None, ignore_authrc=False,
            trust_all_ssl_certificates=False,
            auth_svc='https://ci.kbase.us/services/auth/api/legacy/KBase/Sessions/Login',
            service_ver='release',
            async_job_check_time_ms=100, async_job_check_time_scale_percent=150, 
            async_job_check_max_time_ms=300000):
        if url is None:
            raise ValueError('A url is required')
        self._service_ver = service_ver
        self._client = _BaseClient(
            url, timeout=timeout, user_id=user_id, password=password,
            token=token, ignore_authrc=ignore_authrc,
            trust_all_ssl_certificates=trust_all_ssl_certificates,
            auth_svc=auth_svc,
            async_job_check_time_ms=async_job_check_time_ms,
            async_job_check_time_scale_percent=async_job_check_time_scale_percent,
            async_job_check_max_time_ms=async_job_check_max_time_ms)

    def estimate_k(self, params, context=None):
        """
        Used as an analysis step before generating clusters using K-means clustering, this method
        provides an estimate of K by [...]
        :param params: instance of type "EstimateKParams" -> structure:
           parameter "input_matrix" of type "ws_matrix_id" (A workspace ID
           that references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter "min_k"
           of Long, parameter "max_k" of Long, parameter "max_iter" of Long,
           parameter "random_seed" of Long, parameter "neighb_size" of Long,
           parameter "max_items" of Long, parameter "out_workspace" of
           String, parameter "out_estimate_result" of String
        """
        return self._client.run_job('KBaseFeatureValues.estimate_k',
                                    [params], self._service_ver, context)

    def estimate_k_new(self, params, context=None):
        """
        Used as an analysis step before generating clusters using K-means clustering, this method
        provides an estimate of K by [...]
        :param params: instance of type "EstimateKParamsNew" -> structure:
           parameter "input_matrix" of type "ws_matrix_id" (A workspace ID
           that references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter "min_k"
           of Long, parameter "max_k" of Long, parameter "criterion" of
           String, parameter "usepam" of type "boolean" (Indicates true or
           false values, false = 0, true = 1 @range [0,1]), parameter "alpha"
           of Double, parameter "diss" of type "boolean" (Indicates true or
           false values, false = 0, true = 1 @range [0,1]), parameter
           "random_seed" of Long, parameter "out_workspace" of String,
           parameter "out_estimate_result" of String
        """
        return self._client.run_job('KBaseFeatureValues.estimate_k_new',
                                    [params], self._service_ver, context)

    def cluster_k_means(self, params, context=None):
        """
        Clusters features by K-means clustering.
        :param params: instance of type "ClusterKMeansParams" -> structure:
           parameter "k" of Long, parameter "input_data" of type
           "ws_matrix_id" (A workspace ID that references a Float2DMatrix
           wrapper data object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "n_start" of Long, parameter "max_iter" of Long, parameter
           "random_seed" of Long, parameter "algorithm" of String, parameter
           "out_workspace" of String, parameter "out_clusterset_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.cluster_k_means',
                                    [params], self._service_ver, context)

    def cluster_hierarchical(self, params, context=None):
        """
        Clusters features by hierarchical clustering.
        :param params: instance of type "ClusterHierarchicalParams" ->
           structure: parameter "distance_metric" of String, parameter
           "linkage_criteria" of String, parameter "feature_height_cutoff" of
           Double, parameter "condition_height_cutoff" of Double, parameter
           "max_items" of Long, parameter "input_data" of type "ws_matrix_id"
           (A workspace ID that references a Float2DMatrix wrapper data
           object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "algorithm" of String, parameter "out_workspace" of String,
           parameter "out_clusterset_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.cluster_hierarchical',
                                    [params], self._service_ver, context)

    def clusters_from_dendrogram(self, params, context=None):
        """
        Given a FeatureClusters with a dendogram built from a hierarchical clustering
        method, this function creates new clusters by cutting the dendogram at
        a specific hieght or by some other approach.
        :param params: instance of type "ClustersFromDendrogramParams" ->
           structure: parameter "feature_height_cutoff" of Double, parameter
           "condition_height_cutoff" of Double, parameter "input_data" of
           type "ws_featureclusters_id" (The workspace ID of a
           FeatureClusters data object. @id ws
           KBaseFeatureValues.FeatureClusters), parameter "out_workspace" of
           String, parameter "out_clusterset_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.clusters_from_dendrogram',
                                    [params], self._service_ver, context)

    def evaluate_clusterset_quality(self, params, context=None):
        """
        Given a FeatureClusters with a dendogram built from a hierarchical clustering
        method, this function creates new clusters by cutting the dendogram at
        a specific hieght or by some other approach.
        :param params: instance of type "EvaluateClustersetQualityParams" ->
           structure: parameter "input_clusterset" of type
           "ws_featureclusters_id" (The workspace ID of a FeatureClusters
           data object. @id ws KBaseFeatureValues.FeatureClusters), parameter
           "out_workspace" of String, parameter "out_report_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.evaluate_clusterset_quality',
                                    [params], self._service_ver, context)

    def validate_matrix(self, params, context=None):
        """
        :param params: instance of type "ValidateMatrixParams" (method -
           optional field specifying special type of validation necessary for
           particular clustering method.) -> structure: parameter "method" of
           String, parameter "input_data" of type "ws_matrix_id" (A workspace
           ID that references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix)
        """
        return self._client.run_job('KBaseFeatureValues.validate_matrix',
                                    [params], self._service_ver, context)

    def correct_matrix(self, params, context=None):
        """
        :param params: instance of type "CorrectMatrixParams" (transform_type
           - type of matrix change (one of: add, multiply, normalize,
           missing, ?). transform_value - optional field defining volume of
           change if it's necessary for chosen transform_type.) -> structure:
           parameter "transform_type" of String, parameter "transform_value"
           of Double, parameter "input_data" of type "ws_matrix_id" (A
           workspace ID that references a Float2DMatrix wrapper data object.
           @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "out_workspace" of String, parameter "out_matrix_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.correct_matrix',
                                    [params], self._service_ver, context)

    def reconnect_matrix_to_genome(self, params, context=None):
        """
        :param params: instance of type "ReconnectMatrixToGenomeParams"
           (out_matrix_id - optional target matrix object name (if not
           specified then target object overwrites input_data).) ->
           structure: parameter "input_data" of type "ws_matrix_id" (A
           workspace ID that references a Float2DMatrix wrapper data object.
           @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "genome_ref" of type "ws_genome_id" (The workspace ID for a Genome
           data object. @id ws KBaseGenomes.Genome), parameter
           "out_workspace" of String, parameter "out_matrix_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.reconnect_matrix_to_genome',
                                    [params], self._service_ver, context)

    def build_feature_set(self, params, context=None):
        """
        :param params: instance of type "BuildFeatureSetParams"
           (base_feature_set - optional field, description - optional field.)
           -> structure: parameter "genome" of type "ws_genome_id" (The
           workspace ID for a Genome data object. @id ws
           KBaseGenomes.Genome), parameter "feature_ids" of String, parameter
           "feature_ids_custom" of String, parameter "base_feature_set" of
           type "ws_featureset_id" (The workspace ID of a FeatureSet data
           object. @id ws KBaseCollections.FeatureSet), parameter
           "description" of String, parameter "out_workspace" of String,
           parameter "output_feature_set" of String
        """
        return self._client.run_job('KBaseFeatureValues.build_feature_set',
                                    [params], self._service_ver, context)

    def get_matrix_descriptor(self, GetMatrixDescriptorParams, context=None):
        """
        :param GetMatrixDescriptorParams: instance of type
           "GetMatrixDescriptorParams" (Parameters to retrieve
           MatrixDescriptor) -> structure: parameter "input_data" of type
           "ws_matrix_id" (A workspace ID that references a Float2DMatrix
           wrapper data object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix)
        :returns: instance of type "MatrixDescriptor" (General info about
           matrix, including genome name that needs to be extracted from the
           genome object) -> structure: parameter "matrix_id" of String,
           parameter "matrix_name" of String, parameter "matrix_description"
           of String, parameter "genome_id" of String, parameter
           "genome_name" of String, parameter "rows_count" of Long, parameter
           "columns_count" of Long, parameter "scale" of String, parameter
           "type" of String, parameter "row_normalization" of String,
           parameter "col_normalization" of String
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_descriptor',
                                    [GetMatrixDescriptorParams], self._service_ver, context)

    def get_matrix_row_descriptors(self, GetMatrixItemDescriptorsParams, context=None):
        """
        :param GetMatrixItemDescriptorsParams: instance of type
           "GetMatrixItemDescriptorsParams" (Parameters to get basic
           properties for items from the Float2D type of matrices. input_data
           - worskapce reference to the ExpressionMatrix object (later we
           should allow to work with other Float2DMatrix-like matrices, e.g.
           fitness) item_indeces - indeces of items for whch descriptors
           should be built. Either item_indeces or item_ids should be
           provided. If both are provided, item_indeces will be used.
           item_ids - ids of items for whch descriptors should be built.
           Either item_indeces or item_ids should be provided. If both are
           provided, item_indeces will be used. requested_property_types -
           list of property types to be populated for each item. Currently
           supported property types are: 'function') -> structure: parameter
           "input_data" of type "ws_matrix_id" (A workspace ID that
           references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "item_indeces" of list of Long, parameter "item_ids" of list of
           String, parameter "requested_property_types" of list of String
        :returns: instance of list of type "ItemDescriptor" (Basic
           information about a particular item in a collection. index - index
           of the item id - id of the item name - name of the item
           description - description of the item properties - additinal
           proerties: key - property type, value - value. For instance, if
           item represents a feature, the property type can be a type of
           feature annotation in a genome, e.g. 'function', 'strand', etc) ->
           structure: parameter "index" of Long, parameter "id" of String,
           parameter "name" of String, parameter "description" of String,
           parameter "properties" of mapping from String to String
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_row_descriptors',
                                    [GetMatrixItemDescriptorsParams], self._service_ver, context)

    def get_matrix_column_descriptors(self, GetMatrixItemDescriptorsParams, context=None):
        """
        :param GetMatrixItemDescriptorsParams: instance of type
           "GetMatrixItemDescriptorsParams" (Parameters to get basic
           properties for items from the Float2D type of matrices. input_data
           - worskapce reference to the ExpressionMatrix object (later we
           should allow to work with other Float2DMatrix-like matrices, e.g.
           fitness) item_indeces - indeces of items for whch descriptors
           should be built. Either item_indeces or item_ids should be
           provided. If both are provided, item_indeces will be used.
           item_ids - ids of items for whch descriptors should be built.
           Either item_indeces or item_ids should be provided. If both are
           provided, item_indeces will be used. requested_property_types -
           list of property types to be populated for each item. Currently
           supported property types are: 'function') -> structure: parameter
           "input_data" of type "ws_matrix_id" (A workspace ID that
           references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "item_indeces" of list of Long, parameter "item_ids" of list of
           String, parameter "requested_property_types" of list of String
        :returns: instance of list of type "ItemDescriptor" (Basic
           information about a particular item in a collection. index - index
           of the item id - id of the item name - name of the item
           description - description of the item properties - additinal
           proerties: key - property type, value - value. For instance, if
           item represents a feature, the property type can be a type of
           feature annotation in a genome, e.g. 'function', 'strand', etc) ->
           structure: parameter "index" of Long, parameter "id" of String,
           parameter "name" of String, parameter "description" of String,
           parameter "properties" of mapping from String to String
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_column_descriptors',
                                    [GetMatrixItemDescriptorsParams], self._service_ver, context)

    def get_matrix_rows_stat(self, GetMatrixItemsStatParams, context=None):
        """
        :param GetMatrixItemsStatParams: instance of type
           "GetMatrixItemsStatParams" (Parameters to get statics for a set of
           items from the Float2D type of matrices. input_data - worskapce
           reference to the ExpressionMatrix object (later we should allow to
           work with other Float2DMatrix-like matrices, e.g. fitness)
           item_indeces_for - indeces of items FOR whch statistics should be
           calculated item_indeces_on - indeces of items ON whch statistics
           should be calculated fl_indeces_on - defines whether the
           indeces_on should be populated in ItemStat objects. The default
           value = 0.) -> structure: parameter "input_data" of type
           "ws_matrix_id" (A workspace ID that references a Float2DMatrix
           wrapper data object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "item_indeces_for" of list of Long, parameter "item_indeces_on" of
           list of Long, parameter "fl_indeces_on" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range [0,1])
        :returns: instance of list of type "ItemStat" (Statistics for a given
           item in a collection (defined by index) , calculated on the
           associated vector of values. Typical example is 2D matrix: item is
           a given row, and correposnding values from all columns is an
           associated vector. In relation to ExpressionMatrix we can think
           about a gene (defined by row index in Float2DMatrix) and a vector
           of expression values across all (or a subset of) conditions. In
           this case, index_for - index of a row representing a gene in the
           Float2DMatrix, indeces_on - indeces of columns represnting a set
           of conditions on which we want to calculate statistics. index_for
           - index of the item in a collection FOR which all statitics is
           collected indeces_on - indeces of items in the associated vector
           ON which the statistics is calculated size - number of elements in
           the associated vector avg - mean value for a given item across all
           elements in the associated vector min - min value for a given item
           across all elements in the associated vector max - max value for a
           given item across all elements in the associated vector std - std
           value for a given item across all elements in the associated
           vector missing_values - number of missing values for a given item
           across all elements in the associated vector) -> structure:
           parameter "index_for" of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avg" of Double,
           parameter "min" of Double, parameter "max" of Double, parameter
           "std" of Double, parameter "missing_values" of Long
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_rows_stat',
                                    [GetMatrixItemsStatParams], self._service_ver, context)

    def get_matrix_columns_stat(self, GetMatrixItemsStatParams, context=None):
        """
        :param GetMatrixItemsStatParams: instance of type
           "GetMatrixItemsStatParams" (Parameters to get statics for a set of
           items from the Float2D type of matrices. input_data - worskapce
           reference to the ExpressionMatrix object (later we should allow to
           work with other Float2DMatrix-like matrices, e.g. fitness)
           item_indeces_for - indeces of items FOR whch statistics should be
           calculated item_indeces_on - indeces of items ON whch statistics
           should be calculated fl_indeces_on - defines whether the
           indeces_on should be populated in ItemStat objects. The default
           value = 0.) -> structure: parameter "input_data" of type
           "ws_matrix_id" (A workspace ID that references a Float2DMatrix
           wrapper data object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "item_indeces_for" of list of Long, parameter "item_indeces_on" of
           list of Long, parameter "fl_indeces_on" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range [0,1])
        :returns: instance of list of type "ItemStat" (Statistics for a given
           item in a collection (defined by index) , calculated on the
           associated vector of values. Typical example is 2D matrix: item is
           a given row, and correposnding values from all columns is an
           associated vector. In relation to ExpressionMatrix we can think
           about a gene (defined by row index in Float2DMatrix) and a vector
           of expression values across all (or a subset of) conditions. In
           this case, index_for - index of a row representing a gene in the
           Float2DMatrix, indeces_on - indeces of columns represnting a set
           of conditions on which we want to calculate statistics. index_for
           - index of the item in a collection FOR which all statitics is
           collected indeces_on - indeces of items in the associated vector
           ON which the statistics is calculated size - number of elements in
           the associated vector avg - mean value for a given item across all
           elements in the associated vector min - min value for a given item
           across all elements in the associated vector max - max value for a
           given item across all elements in the associated vector std - std
           value for a given item across all elements in the associated
           vector missing_values - number of missing values for a given item
           across all elements in the associated vector) -> structure:
           parameter "index_for" of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avg" of Double,
           parameter "min" of Double, parameter "max" of Double, parameter
           "std" of Double, parameter "missing_values" of Long
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_columns_stat',
                                    [GetMatrixItemsStatParams], self._service_ver, context)

    def get_matrix_row_sets_stat(self, GetMatrixSetsStatParams, context=None):
        """
        :param GetMatrixSetsStatParams: instance of type
           "GetMatrixSetsStatParams" (Parameters to retrieve statistics for
           set of sets of elements. In relation to ExpressionMatrix, these
           parameters can be used to retrive sparklines for several gene
           clusters generated on the same ExpressionMatrix in one call.
           params - list of params to retrive statistics for a set of items
           from the Float2D type of matrices.) -> structure: parameter
           "params" of list of type "GetMatrixSetStatParams" (Parameters to
           get statistics for a set of items from the Float2D type of
           matrices in a form of ItemSetStat. This version is more flexible
           and will be later used to retrieve set of sets of elements.
           input_data - worskapce reference to the ExpressionMatrix object
           (later we should allow to work with other Float2DMatrix-like
           matrices, e.g. fitness) item_indeces_for - indeces of items FOR
           wich statistics should be calculated item_indeces_on - indeces of
           items ON wich statistics should be calculated fl_indeces_on -
           defines whether the indeces_on should be populated in SetStat
           objects. The default value = 0. fl_indeces_for - defines whether
           the indeces_for should be populated in SetStat objects. The
           default value = 0. fl_avgs - defines whether the avgs should be
           populated in SetStat objects. The default value = 0. fl_mins -
           defines whether the mins should be populated in SetStat objects.
           The default value = 0. fl_maxs - defines whether the maxs should
           be populated in SetStat objects. The default value = 0. fl_stds -
           defines whether the stds should be populated in SetStat objects.
           The default value = 0. fl_missing_values - defines whether the
           missing_values should be populated in SetStat objects. The default
           value = 0.) -> structure: parameter "input_data" of type
           "ws_matrix_id" (A workspace ID that references a Float2DMatrix
           wrapper data object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "item_indeces_for" of list of Long, parameter "item_indeces_on" of
           list of Long, parameter "fl_indeces_on" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_indeces_for" of type "boolean" (Indicates
           true or false values, false = 0, true = 1 @range [0,1]), parameter
           "fl_avgs" of type "boolean" (Indicates true or false values, false
           = 0, true = 1 @range [0,1]), parameter "fl_mins" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_maxs" of type "boolean" (Indicates true or
           false values, false = 0, true = 1 @range [0,1]), parameter
           "fl_stds" of type "boolean" (Indicates true or false values, false
           = 0, true = 1 @range [0,1]), parameter "fl_missing_values" of type
           "boolean" (Indicates true or false values, false = 0, true = 1
           @range [0,1])
        :returns: instance of list of type "ItemSetStat" (Same as ItemStat,
           but for a set of Items. Actually it can be modeled as a
           list<ItemStat>, but this way we can optimize data transfer in two
           ways: 1. In parameters we can specify that we need a subset of
           properties, e.g. only "avgs". 2. No field names in json (avg, min,
           max, etc) for each element in the list indeces_for - indeces of
           items in a collection FOR which all statitics is collected
           indeces_on - indeces of items in the associated vector ON which
           the statistics is calculated size - number of elements defined by
           indeces_on (expected to be the same for all items defined by
           indeces_for) avgs - mean values for each item defined by
           indeces_for across all elements defined by indeces_on mins - min
           values for each item defined by indeces_for across all elements
           defined by indeces_on maxs - max values for each item defined by
           indeces_for across all elements defined by indeces_on stds - std
           values for each item defined by indeces_for across all elements
           defined by indeces_on missing_values - number of missing values
           for each item defined by indeces_for across all elements defined
           by indeces_on) -> structure: parameter "indeces_for" of list of
           Long, parameter "indeces_on" of list of Long, parameter "size" of
           Long, parameter "avgs" of list of Double, parameter "mins" of list
           of Double, parameter "maxs" of list of Double, parameter "stds" of
           list of Double, parameter "missing_values" of list of Long
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_row_sets_stat',
                                    [GetMatrixSetsStatParams], self._service_ver, context)

    def get_matrix_column_sets_stat(self, GetMatrixSetsStatParams, context=None):
        """
        :param GetMatrixSetsStatParams: instance of type
           "GetMatrixSetsStatParams" (Parameters to retrieve statistics for
           set of sets of elements. In relation to ExpressionMatrix, these
           parameters can be used to retrive sparklines for several gene
           clusters generated on the same ExpressionMatrix in one call.
           params - list of params to retrive statistics for a set of items
           from the Float2D type of matrices.) -> structure: parameter
           "params" of list of type "GetMatrixSetStatParams" (Parameters to
           get statistics for a set of items from the Float2D type of
           matrices in a form of ItemSetStat. This version is more flexible
           and will be later used to retrieve set of sets of elements.
           input_data - worskapce reference to the ExpressionMatrix object
           (later we should allow to work with other Float2DMatrix-like
           matrices, e.g. fitness) item_indeces_for - indeces of items FOR
           wich statistics should be calculated item_indeces_on - indeces of
           items ON wich statistics should be calculated fl_indeces_on -
           defines whether the indeces_on should be populated in SetStat
           objects. The default value = 0. fl_indeces_for - defines whether
           the indeces_for should be populated in SetStat objects. The
           default value = 0. fl_avgs - defines whether the avgs should be
           populated in SetStat objects. The default value = 0. fl_mins -
           defines whether the mins should be populated in SetStat objects.
           The default value = 0. fl_maxs - defines whether the maxs should
           be populated in SetStat objects. The default value = 0. fl_stds -
           defines whether the stds should be populated in SetStat objects.
           The default value = 0. fl_missing_values - defines whether the
           missing_values should be populated in SetStat objects. The default
           value = 0.) -> structure: parameter "input_data" of type
           "ws_matrix_id" (A workspace ID that references a Float2DMatrix
           wrapper data object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "item_indeces_for" of list of Long, parameter "item_indeces_on" of
           list of Long, parameter "fl_indeces_on" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_indeces_for" of type "boolean" (Indicates
           true or false values, false = 0, true = 1 @range [0,1]), parameter
           "fl_avgs" of type "boolean" (Indicates true or false values, false
           = 0, true = 1 @range [0,1]), parameter "fl_mins" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_maxs" of type "boolean" (Indicates true or
           false values, false = 0, true = 1 @range [0,1]), parameter
           "fl_stds" of type "boolean" (Indicates true or false values, false
           = 0, true = 1 @range [0,1]), parameter "fl_missing_values" of type
           "boolean" (Indicates true or false values, false = 0, true = 1
           @range [0,1])
        :returns: instance of list of type "ItemSetStat" (Same as ItemStat,
           but for a set of Items. Actually it can be modeled as a
           list<ItemStat>, but this way we can optimize data transfer in two
           ways: 1. In parameters we can specify that we need a subset of
           properties, e.g. only "avgs". 2. No field names in json (avg, min,
           max, etc) for each element in the list indeces_for - indeces of
           items in a collection FOR which all statitics is collected
           indeces_on - indeces of items in the associated vector ON which
           the statistics is calculated size - number of elements defined by
           indeces_on (expected to be the same for all items defined by
           indeces_for) avgs - mean values for each item defined by
           indeces_for across all elements defined by indeces_on mins - min
           values for each item defined by indeces_for across all elements
           defined by indeces_on maxs - max values for each item defined by
           indeces_for across all elements defined by indeces_on stds - std
           values for each item defined by indeces_for across all elements
           defined by indeces_on missing_values - number of missing values
           for each item defined by indeces_for across all elements defined
           by indeces_on) -> structure: parameter "indeces_for" of list of
           Long, parameter "indeces_on" of list of Long, parameter "size" of
           Long, parameter "avgs" of list of Double, parameter "mins" of list
           of Double, parameter "maxs" of list of Double, parameter "stds" of
           list of Double, parameter "missing_values" of list of Long
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_column_sets_stat',
                                    [GetMatrixSetsStatParams], self._service_ver, context)

    def get_matrix_stat(self, GetMatrixStatParams, context=None):
        """
        :param GetMatrixStatParams: instance of type "GetMatrixStatParams"
           (Parameters to retrieve MatrixStat) -> structure: parameter
           "input_data" of type "ws_matrix_id" (A workspace ID that
           references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix)
        :returns: instance of type "MatrixStat" (Data type for bulk queries.
           It provides all necessary data to visulize basic properties of
           ExpressionMatrix mtx_descriptor - decriptor of the matrix as a
           whole row_descriptors - descriptor for each row in the matrix
           (provides basic properties of the features) column_descriptors -
           descriptor for each column in the matrix (provides basic
           properties of the conditions) row_stats - basic statistics for
           each row (feature) in the matrix, like mean, min, max, etc acorss
           all columns (conditions) column_stats - basic statistics for each
           row (feature) in the matrix, like mean, min, max, etc across all
           rows (features)) -> structure: parameter "mtx_descriptor" of type
           "MatrixDescriptor" (General info about matrix, including genome
           name that needs to be extracted from the genome object) ->
           structure: parameter "matrix_id" of String, parameter
           "matrix_name" of String, parameter "matrix_description" of String,
           parameter "genome_id" of String, parameter "genome_name" of
           String, parameter "rows_count" of Long, parameter "columns_count"
           of Long, parameter "scale" of String, parameter "type" of String,
           parameter "row_normalization" of String, parameter
           "col_normalization" of String, parameter "row_descriptors" of list
           of type "ItemDescriptor" (Basic information about a particular
           item in a collection. index - index of the item id - id of the
           item name - name of the item description - description of the item
           properties - additinal proerties: key - property type, value -
           value. For instance, if item represents a feature, the property
           type can be a type of feature annotation in a genome, e.g.
           'function', 'strand', etc) -> structure: parameter "index" of
           Long, parameter "id" of String, parameter "name" of String,
           parameter "description" of String, parameter "properties" of
           mapping from String to String, parameter "column_descriptors" of
           list of type "ItemDescriptor" (Basic information about a
           particular item in a collection. index - index of the item id - id
           of the item name - name of the item description - description of
           the item properties - additinal proerties: key - property type,
           value - value. For instance, if item represents a feature, the
           property type can be a type of feature annotation in a genome,
           e.g. 'function', 'strand', etc) -> structure: parameter "index" of
           Long, parameter "id" of String, parameter "name" of String,
           parameter "description" of String, parameter "properties" of
           mapping from String to String, parameter "row_stats" of list of
           type "ItemStat" (Statistics for a given item in a collection
           (defined by index) , calculated on the associated vector of
           values. Typical example is 2D matrix: item is a given row, and
           correposnding values from all columns is an associated vector. In
           relation to ExpressionMatrix we can think about a gene (defined by
           row index in Float2DMatrix) and a vector of expression values
           across all (or a subset of) conditions. In this case, index_for -
           index of a row representing a gene in the Float2DMatrix,
           indeces_on - indeces of columns represnting a set of conditions on
           which we want to calculate statistics. index_for - index of the
           item in a collection FOR which all statitics is collected
           indeces_on - indeces of items in the associated vector ON which
           the statistics is calculated size - number of elements in the
           associated vector avg - mean value for a given item across all
           elements in the associated vector min - min value for a given item
           across all elements in the associated vector max - max value for a
           given item across all elements in the associated vector std - std
           value for a given item across all elements in the associated
           vector missing_values - number of missing values for a given item
           across all elements in the associated vector) -> structure:
           parameter "index_for" of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avg" of Double,
           parameter "min" of Double, parameter "max" of Double, parameter
           "std" of Double, parameter "missing_values" of Long, parameter
           "column_stats" of list of type "ItemStat" (Statistics for a given
           item in a collection (defined by index) , calculated on the
           associated vector of values. Typical example is 2D matrix: item is
           a given row, and correposnding values from all columns is an
           associated vector. In relation to ExpressionMatrix we can think
           about a gene (defined by row index in Float2DMatrix) and a vector
           of expression values across all (or a subset of) conditions. In
           this case, index_for - index of a row representing a gene in the
           Float2DMatrix, indeces_on - indeces of columns represnting a set
           of conditions on which we want to calculate statistics. index_for
           - index of the item in a collection FOR which all statitics is
           collected indeces_on - indeces of items in the associated vector
           ON which the statistics is calculated size - number of elements in
           the associated vector avg - mean value for a given item across all
           elements in the associated vector min - min value for a given item
           across all elements in the associated vector max - max value for a
           given item across all elements in the associated vector std - std
           value for a given item across all elements in the associated
           vector missing_values - number of missing values for a given item
           across all elements in the associated vector) -> structure:
           parameter "index_for" of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avg" of Double,
           parameter "min" of Double, parameter "max" of Double, parameter
           "std" of Double, parameter "missing_values" of Long
        """
        return self._client.run_job('KBaseFeatureValues.get_matrix_stat',
                                    [GetMatrixStatParams], self._service_ver, context)

    def get_submatrix_stat(self, GetSubmatrixStatParams, context=None):
        """
        :param GetSubmatrixStatParams: instance of type
           "GetSubmatrixStatParams" (Parameters to retrieve SubmatrixStat
           input_data - reference to the source matrix row_indeces - indeces
           defining a subset of matrix rows. Either row_indeces (highest
           priorery) or row_ids should be provided. row_ids - ids defining a
           subset of matrix rows. Either row_indeces (highest priorery) or
           row_ids should be provided. column_indeces - indeces defining a
           subset of matrix columns. Either column_indeces (highest priorery)
           or column_ids should be provided. column_ids - ids defining a
           subset of matrix columns. Either column_indeces (highest priorery)
           or column_ids should be provided. fl_row_set_stats - defines
           whether row_set_stats should be calculated in include in the
           SubmatrixStat. Default value = 0 fl_column_set_stat - defines
           whether column_set_stat should be calculated in include in the
           SubmatrixStat. Default value = 0 fl_mtx_row_set_stat - defines
           whether mtx_row_set_stat should be calculated in include in the
           SubmatrixStat. Default value = 0 fl_mtx_column_set_stat - defines
           whether mtx_column_set_stat should be calculated in include in the
           SubmatrixStat. Default value = 0 fl_row_pairwise_correlation -
           defines whether row_pairwise_correlation should be calculated in
           include in the SubmatrixStat. Default value = 0
           fl_column_pairwise_correlation - defines whether
           column_pairwise_correlation should be calculated in include in the
           SubmatrixStat. Default value = 0 fl_values - defines whether
           values should be calculated in include in the SubmatrixStat.
           Default value = 0) -> structure: parameter "input_data" of type
           "ws_matrix_id" (A workspace ID that references a Float2DMatrix
           wrapper data object. @id ws KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "row_indeces" of list of Long, parameter "row_ids" of list of
           String, parameter "column_indeces" of list of Long, parameter
           "column_ids" of list of String, parameter "fl_row_set_stats" of
           type "boolean" (Indicates true or false values, false = 0, true =
           1 @range [0,1]), parameter "fl_column_set_stat" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_mtx_row_set_stat" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_mtx_column_set_stat" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_row_pairwise_correlation" of type "boolean"
           (Indicates true or false values, false = 0, true = 1 @range
           [0,1]), parameter "fl_column_pairwise_correlation" of type
           "boolean" (Indicates true or false values, false = 0, true = 1
           @range [0,1]), parameter "fl_values" of type "boolean" (Indicates
           true or false values, false = 0, true = 1 @range [0,1])
        :returns: instance of type "SubmatrixStat" (Data type for bulk
           queries. It provides various statistics calculated on sub-matrix.
           The sub-matrix is defined by a subset of rows and columns via
           parameters. Parameters will also define the required types of
           statics. mtx_descriptor - basic properties of the source matrix
           row_descriptors - descriptor for each row in a subset defined in
           the parameters column_descriptors - descriptor for each column in
           a subset defined in the parameters row_set_stats - basic
           statistics for a subset of rows calculated on a subset of columns
           column_set_stat - basic statistics for a subset of columns
           calculated on a subset of rows mtx_row_set_stat - basic statistics
           for a subset of rows calculated on ALL columns in the matrix (can
           be used as a backgound in comparison with row_set_stats)
           mtx_column_set_stat - basic statistics for a subset of columns
           calculated on ALL rows in the matrix (can be used as a backgound
           in comparison with column_set_stat) row_pairwise_correlation -
           pariwise perason correlation for a subset of rows (features)
           column_pairwise_correlation - pariwise perason correlation for a
           subset of columns (conditions) values - sub-matrix representing
           actual values for a given subset of rows and a subset of columns)
           -> structure: parameter "mtx_descriptor" of type
           "MatrixDescriptor" (General info about matrix, including genome
           name that needs to be extracted from the genome object) ->
           structure: parameter "matrix_id" of String, parameter
           "matrix_name" of String, parameter "matrix_description" of String,
           parameter "genome_id" of String, parameter "genome_name" of
           String, parameter "rows_count" of Long, parameter "columns_count"
           of Long, parameter "scale" of String, parameter "type" of String,
           parameter "row_normalization" of String, parameter
           "col_normalization" of String, parameter "row_descriptors" of list
           of type "ItemDescriptor" (Basic information about a particular
           item in a collection. index - index of the item id - id of the
           item name - name of the item description - description of the item
           properties - additinal proerties: key - property type, value -
           value. For instance, if item represents a feature, the property
           type can be a type of feature annotation in a genome, e.g.
           'function', 'strand', etc) -> structure: parameter "index" of
           Long, parameter "id" of String, parameter "name" of String,
           parameter "description" of String, parameter "properties" of
           mapping from String to String, parameter "column_descriptors" of
           list of type "ItemDescriptor" (Basic information about a
           particular item in a collection. index - index of the item id - id
           of the item name - name of the item description - description of
           the item properties - additinal proerties: key - property type,
           value - value. For instance, if item represents a feature, the
           property type can be a type of feature annotation in a genome,
           e.g. 'function', 'strand', etc) -> structure: parameter "index" of
           Long, parameter "id" of String, parameter "name" of String,
           parameter "description" of String, parameter "properties" of
           mapping from String to String, parameter "row_set_stats" of type
           "ItemSetStat" (Same as ItemStat, but for a set of Items. Actually
           it can be modeled as a list<ItemStat>, but this way we can
           optimize data transfer in two ways: 1. In parameters we can
           specify that we need a subset of properties, e.g. only "avgs". 2.
           No field names in json (avg, min, max, etc) for each element in
           the list indeces_for - indeces of items in a collection FOR which
           all statitics is collected indeces_on - indeces of items in the
           associated vector ON which the statistics is calculated size -
           number of elements defined by indeces_on (expected to be the same
           for all items defined by indeces_for) avgs - mean values for each
           item defined by indeces_for across all elements defined by
           indeces_on mins - min values for each item defined by indeces_for
           across all elements defined by indeces_on maxs - max values for
           each item defined by indeces_for across all elements defined by
           indeces_on stds - std values for each item defined by indeces_for
           across all elements defined by indeces_on missing_values - number
           of missing values for each item defined by indeces_for across all
           elements defined by indeces_on) -> structure: parameter
           "indeces_for" of list of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avgs" of list of
           Double, parameter "mins" of list of Double, parameter "maxs" of
           list of Double, parameter "stds" of list of Double, parameter
           "missing_values" of list of Long, parameter "column_set_stat" of
           type "ItemSetStat" (Same as ItemStat, but for a set of Items.
           Actually it can be modeled as a list<ItemStat>, but this way we
           can optimize data transfer in two ways: 1. In parameters we can
           specify that we need a subset of properties, e.g. only "avgs". 2.
           No field names in json (avg, min, max, etc) for each element in
           the list indeces_for - indeces of items in a collection FOR which
           all statitics is collected indeces_on - indeces of items in the
           associated vector ON which the statistics is calculated size -
           number of elements defined by indeces_on (expected to be the same
           for all items defined by indeces_for) avgs - mean values for each
           item defined by indeces_for across all elements defined by
           indeces_on mins - min values for each item defined by indeces_for
           across all elements defined by indeces_on maxs - max values for
           each item defined by indeces_for across all elements defined by
           indeces_on stds - std values for each item defined by indeces_for
           across all elements defined by indeces_on missing_values - number
           of missing values for each item defined by indeces_for across all
           elements defined by indeces_on) -> structure: parameter
           "indeces_for" of list of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avgs" of list of
           Double, parameter "mins" of list of Double, parameter "maxs" of
           list of Double, parameter "stds" of list of Double, parameter
           "missing_values" of list of Long, parameter "mtx_row_set_stat" of
           type "ItemSetStat" (Same as ItemStat, but for a set of Items.
           Actually it can be modeled as a list<ItemStat>, but this way we
           can optimize data transfer in two ways: 1. In parameters we can
           specify that we need a subset of properties, e.g. only "avgs". 2.
           No field names in json (avg, min, max, etc) for each element in
           the list indeces_for - indeces of items in a collection FOR which
           all statitics is collected indeces_on - indeces of items in the
           associated vector ON which the statistics is calculated size -
           number of elements defined by indeces_on (expected to be the same
           for all items defined by indeces_for) avgs - mean values for each
           item defined by indeces_for across all elements defined by
           indeces_on mins - min values for each item defined by indeces_for
           across all elements defined by indeces_on maxs - max values for
           each item defined by indeces_for across all elements defined by
           indeces_on stds - std values for each item defined by indeces_for
           across all elements defined by indeces_on missing_values - number
           of missing values for each item defined by indeces_for across all
           elements defined by indeces_on) -> structure: parameter
           "indeces_for" of list of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avgs" of list of
           Double, parameter "mins" of list of Double, parameter "maxs" of
           list of Double, parameter "stds" of list of Double, parameter
           "missing_values" of list of Long, parameter "mtx_column_set_stat"
           of type "ItemSetStat" (Same as ItemStat, but for a set of Items.
           Actually it can be modeled as a list<ItemStat>, but this way we
           can optimize data transfer in two ways: 1. In parameters we can
           specify that we need a subset of properties, e.g. only "avgs". 2.
           No field names in json (avg, min, max, etc) for each element in
           the list indeces_for - indeces of items in a collection FOR which
           all statitics is collected indeces_on - indeces of items in the
           associated vector ON which the statistics is calculated size -
           number of elements defined by indeces_on (expected to be the same
           for all items defined by indeces_for) avgs - mean values for each
           item defined by indeces_for across all elements defined by
           indeces_on mins - min values for each item defined by indeces_for
           across all elements defined by indeces_on maxs - max values for
           each item defined by indeces_for across all elements defined by
           indeces_on stds - std values for each item defined by indeces_for
           across all elements defined by indeces_on missing_values - number
           of missing values for each item defined by indeces_for across all
           elements defined by indeces_on) -> structure: parameter
           "indeces_for" of list of Long, parameter "indeces_on" of list of
           Long, parameter "size" of Long, parameter "avgs" of list of
           Double, parameter "mins" of list of Double, parameter "maxs" of
           list of Double, parameter "stds" of list of Double, parameter
           "missing_values" of list of Long, parameter
           "row_pairwise_correlation" of type "PairwiseComparison" (To
           represent a pairwise comparison of several elements defined by
           'indeces'. This data type can be used to model represent pairwise
           correlation of expression profiles for a set of genes. indeces -
           indeces of elements to be compared comparison_values - values
           representing a parituclar type of comparison between elements.
           Expected to be symmetric: comparison_values[i][j] =
           comparison_values[j][i]. Diagonal values: comparison_values[i][i]
           = 0 avgs - mean of comparison_values for each element mins - min
           of comparison_values for each element maxs - max of
           comparison_values for each element stds - std of comparison_values
           for each element) -> structure: parameter "indeces" of list of
           Long, parameter "comparison_values" of list of list of Double,
           parameter "avgs" of list of Double, parameter "mins" of list of
           Double, parameter "maxs" of list of Double, parameter "stds" of
           list of Double, parameter "column_pairwise_correlation" of type
           "PairwiseComparison" (To represent a pairwise comparison of
           several elements defined by 'indeces'. This data type can be used
           to model represent pairwise correlation of expression profiles for
           a set of genes. indeces - indeces of elements to be compared
           comparison_values - values representing a parituclar type of
           comparison between elements. Expected to be symmetric:
           comparison_values[i][j] = comparison_values[j][i]. Diagonal
           values: comparison_values[i][i] = 0 avgs - mean of
           comparison_values for each element mins - min of comparison_values
           for each element maxs - max of comparison_values for each element
           stds - std of comparison_values for each element) -> structure:
           parameter "indeces" of list of Long, parameter "comparison_values"
           of list of list of Double, parameter "avgs" of list of Double,
           parameter "mins" of list of Double, parameter "maxs" of list of
           Double, parameter "stds" of list of Double, parameter "values" of
           list of list of Double
        """
        return self._client.run_job('KBaseFeatureValues.get_submatrix_stat',
                                    [GetSubmatrixStatParams], self._service_ver, context)

    def tsv_file_to_matrix(self, params, context=None):
        """
        :param params: instance of type "TsvFileToMatrixParams"
           (input_shock_id and input_file_path - alternative intput params,
           genome_ref - optional reference to a Genome object that will be
           used for mapping feature IDs to, fill_missing_values - optional
           flag for filling in missing values in matrix (default value is
           false), data_type - optional filed, value is one of
           'untransformed', 'log2_level', 'log10_level', 'log2_ratio',
           'log10_ratio' or 'unknown' (last one is default value), data_scale
           - optional parameter (default value is '1.0').) -> structure:
           parameter "input_shock_id" of String, parameter "input_file_path"
           of String, parameter "genome_ref" of type "ws_genome_id" (The
           workspace ID for a Genome data object. @id ws
           KBaseGenomes.Genome), parameter "fill_missing_values" of type
           "boolean" (Indicates true or false values, false = 0, true = 1
           @range [0,1]), parameter "data_type" of String, parameter
           "data_scale" of String, parameter "output_ws_name" of String,
           parameter "output_obj_name" of String
        :returns: instance of type "TsvFileToMatrixOutput" -> structure:
           parameter "output_matrix_ref" of type "ws_matrix_id" (A workspace
           ID that references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix)
        """
        return self._client.run_job('KBaseFeatureValues.tsv_file_to_matrix',
                                    [params], self._service_ver, context)

    def matrix_to_tsv_file(self, params, context=None):
        """
        :param params: instance of type "MatrixToTsvFileParams" -> structure:
           parameter "input_ref" of type "ws_matrix_id" (A workspace ID that
           references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix), parameter
           "to_shock" of type "boolean" (Indicates true or false values,
           false = 0, true = 1 @range [0,1]), parameter "file_path" of String
        :returns: instance of type "MatrixToTsvFileOutput" -> structure:
           parameter "file_path" of String, parameter "shock_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.matrix_to_tsv_file',
                                    [params], self._service_ver, context)

    def export_matrix(self, params, context=None):
        """
        :param params: instance of type "ExportMatrixParams" -> structure:
           parameter "input_ref" of type "ws_matrix_id" (A workspace ID that
           references a Float2DMatrix wrapper data object. @id ws
           KBaseFeatureValues.ExpressionMatrix
           KBaseFeatureValues.SingleKnockoutFitnessMatrix)
        :returns: instance of type "ExportMatrixOutput" -> structure:
           parameter "shock_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.export_matrix',
                                    [params], self._service_ver, context)

    def clusters_to_file(self, params, context=None):
        """
        :param params: instance of type "ClustersToFileParams" (format -
           optional field, can be one of "TSV" or "SIF" ("TSV" is default
           value).) -> structure: parameter "input_ref" of type
           "ws_featureclusters_id" (The workspace ID of a FeatureClusters
           data object. @id ws KBaseFeatureValues.FeatureClusters), parameter
           "to_shock" of type "boolean" (Indicates true or false values,
           false = 0, true = 1 @range [0,1]), parameter "file_path" of
           String, parameter "format" of String
        :returns: instance of type "ClustersToFileOutput" -> structure:
           parameter "file_path" of String, parameter "shock_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.clusters_to_file',
                                    [params], self._service_ver, context)

    def export_clusters_tsv(self, params, context=None):
        """
        :param params: instance of type "ExportClustersTsvParams" ->
           structure: parameter "input_ref" of type "ws_featureclusters_id"
           (The workspace ID of a FeatureClusters data object. @id ws
           KBaseFeatureValues.FeatureClusters)
        :returns: instance of type "ExportClustersTsvOutput" -> structure:
           parameter "shock_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.export_clusters_tsv',
                                    [params], self._service_ver, context)

    def export_clusters_sif(self, params, context=None):
        """
        :param params: instance of type "ExportClustersSifParams" ->
           structure: parameter "input_ref" of type "ws_featureclusters_id"
           (The workspace ID of a FeatureClusters data object. @id ws
           KBaseFeatureValues.FeatureClusters)
        :returns: instance of type "ExportClustersSifOutput" -> structure:
           parameter "shock_id" of String
        """
        return self._client.run_job('KBaseFeatureValues.export_clusters_sif',
                                    [params], self._service_ver, context)

    def status(self, context=None):
        return self._client.run_job('KBaseFeatureValues.status',
                                    [], self._service_ver, context)
